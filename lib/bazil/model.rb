require 'rubygems'
require 'json'

module Bazil
  class Model
    attr_reader :application, :name

    def initialize(client, app, name, default_config_id = nil)
      @client = client
      @http_cli = client.http_client
      @application = app
      @name = name

      # Model#initialize does not have config_id
      if default_config_id
        set_default_config_id(default_config_id)
        status
      end
    end

    def set_default_config_id(id)
      @default_config_id = id
    end

    def get_default_config_id
      raise 'default_config_id is not set' if @default_config_id.nil?
      @default_config_id
    end

    def status(config_id = get_default_config_id)
      res = @http_cli.get(gen_uri(target_path(config_id, "status")))
      raise_error("Failed to get status of the model: #{error_suffix}", res) unless res.code =~ /2[0-9][0-9]/
      JSON.parse(res.body)
    end

    def model_config
      res = @http_cli.get(gen_uri("config"))
      raise_error("Failed to get model config: #{error_suffix}", res) unless res.code =~ /2[0-9][0-9]/
      JSON.parse(res.body)
    end

    def update_model_config(conf)
      res = send(:put, 'config', conf.to_json, "Failed to update model config")
      JSON.parse(res)
    end

    def config(config_id = get_default_config_id)
      res = @http_cli.get(gen_uri("configs/#{config_id}"))
      raise_error("Failed to get config of the model: #{error_suffix}", res) unless res.code =~ /2[0-9][0-9]/
      JSON.parse(res.body)
    end

    def config_ids
      res = @http_cli.get(gen_uri('configs'))
      raise_error("Failed to get config of the model: #{error_suffix}", res) unless res.code =~ /2[0-9][0-9]/
      JSON.parse(res.body)['config_ids']
    end

    # if new_config_id is nil, an id of configuration is generated by bazil server
    def create_config(new_config_id, new_config)
      # TODO: type check of id
      data = new_config.dup
      if new_config_id
        data['id'] = new_config_id
      else
        data.delete('id')
      end
      body = post('configs', data.to_json, "Failed to create new configuration")
      JSON.parse(body)
    end

    def update_config(config, config_id = get_default_config_id)
      res = send(:put, "configs/#{config_id}", config.to_json, "Failed to updated config")
      true
    end

    def delete_config(id)
      # TODO: type check of id
      res = @http_cli.delete(gen_uri("configs/#{id}"))
      raise_error("Failed to delete a configuration: id = #{id}, #{error_suffix}", res) unless res.code =~ /2[0-9][0-9]/
      true
    end

    # if new_config_id is nil, an id of configuration is generated by bazil server
    def clone_config(new_config_id, options, base_config_id = get_default_config_id)
      base_config = config(base_config_id)
      create_config(new_config_id, base_config.merge(options))
    end

    def query_configs(query)
      body = post('configs/query', query.to_json, "Failed to query model configurations")
      JSON.parse(body)
    end

    # TODO: label APIs

    def train(annotation, data, config_id = get_default_config_id)
      raise ArgumentError, 'Annotation must be not nil' if annotation.nil?
      raise ArgumentError, 'Data must be not nil' if data.nil?

      new_data = {}
      new_data['annotation'] = annotation if annotation
      new_data['data'] = data if data
      new_data['config_id'] = config_id if config_id
      body = post("training_data", new_data.to_json, "Failed to post training data")
      JSON.parse(body)
    end

    def retrain(option = {}, config_id = get_default_config_id)
      body = post(target_path(config_id, 'retrain'), option.to_json, "Failed to retrain the model")
      JSON.parse(body)
    end

    def trace(method, data, config_id = get_default_config_id)
      new_data = {}
      new_data['method'] = method if method
      new_data['data'] = data if data
      body = post(target_path(config_id, "trace"), new_data.to_json, "Failed to execute trace")
      JSON.parse(body)
    end

    def evaluate(method, config, config_id = get_default_config_id)
      new_data = {}
      new_data['method'] = method if method
      new_data['config'] = config if config
      body = post(target_path(config_id, "evaluate"), new_data.to_json, "Failed to execute evaluate")
      JSON.parse(body)
    end

    def labels(config_id = get_default_config_id)
      res = @http_cli.get(gen_uri(target_path(config_id, "labels")))
      raise_error("Failed to get labels the model has: #{error_suffix}", res) unless res.code =~ /2[0-9][0-9]/
      JSON.parse(res.body)['labels']
    end

    def training_data_num
      list_training_data({})['total']
    end

    def training_data(id)
      res = @http_cli.get(gen_uri("training_data/#{id}"))
      raise_error("Failed to get training data of the model: id = #{id}, #{error_suffix}", res) unless res.code =~ /2[0-9][0-9]/
      JSON.parse(res.body)
    end

    def list_training_data(condition)
      # TODO: validate parameter
      condition = condition.dup
      condition[:page] ||= 1
      condition[:page_size] ||= 10
      condition[:query] ||= { :version => '1' }
      condition[:query][:version] = '1' unless condition[:query][:version]

      res = post("training_data/query?page=#{condition[:page]}&page_size=#{condition[:page_size]}",
                 condition[:query].to_json, "Failed to query training data of the model")
      JSON.parse(res)
    end

    def clear_training_data
      res = @http_cli.delete(gen_uri("training_data"))
      raise_error("Failed to clear training_data of the model: #{error_suffix}", res) unless res.code =~ /2[0-9][0-9]/
      true
    end

    # TODO: Merge put_labeled_training_data
    def put_training_data(data, config_id = get_default_config_id)
      new_data = {}
      new_data['data'] = data
      new_data['config_id'] = config_id if config_id
      body = post('training_data', new_data.to_json, "Failed to post training data")
      JSON.parse(body)
    end

    def put_annotated_training_data(annotation, data, config_id = get_default_config_id)
      new_data = {}
      new_data['annotation'] = annotation if annotation
      new_data['data'] = data if data
      new_data['config_id'] = config_id if config_id
      body = post('training_data', new_data.to_json, "Failed to post training data")
      JSON.parse(body)
    end

    def put_labeled_training_data(annotation, data, config_id = get_default_config_id)
      put_annotated_training_data(annotation, data, config_id)
    end

    def update_training_data(id, annotation, data, config_id = get_default_config_id)
      # TODO: type check of id
      new_data = {}
      new_data['annotation'] = annotation if annotation
      new_data['data'] = data if data
      new_data['config_id'] = config_id
      send(:put, "training_data/#{id}", new_data.to_json, "Failed to update training data")
      true
    end

    def delete_training_data(id)
      # TODO: type check of id
      res = @http_cli.delete(gen_uri("training_data/#{id}"))
      raise_error("Failed to delete a training data: id = #{id}, #{error_suffix}", res) unless res.code =~ /2[0-9][0-9]/
      true
    end

    def query(data, config_id = get_default_config_id)
      data = {'data' => data}.to_json
      res = JSON.parse(post(target_path(config_id, 'query'), data, "Failed to post data for query"))
      return res['max_label'], res
    end

    private

    def post(path, data, error_message)
      send(:post, path, data, error_message)
    end

    def send(method, path, data, error_message)
      res = @http_cli.method(method).call(gen_uri(path), data, {'Content-Type' => 'application/json; charset=UTF-8', 'Content-Length' => data.length.to_s})
      raise_error("#{error_message}: #{error_suffix}", res) unless res.code =~ /2[0-9][0-9]/ # TODO: enhance error information
      res.body
    end

    def target_path(id, path)
      "configs/#{id}/#{path}"
    end

    def gen_uri(path = nil)
      if path
        "/#{@client.api_version}/apps/#{@application.name}/models/#{@name}/#{path}"
      else
        "/#{@client.api_version}/apps/#{@application.name}/models/#{@name}"
      end
    end

    def error_suffix
      "application = #{@application.name}, model = #{@name}"
    end

    def raise_error(message, res)
      raise APIError.new(message, res.code, JSON.parse(res.body))
    end
  end # module Model
end # module Bazil
